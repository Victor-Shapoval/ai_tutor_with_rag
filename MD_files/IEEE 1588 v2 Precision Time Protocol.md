## IEEE 1588 v2 Precision Time Protocol (PTP)

Протокол PTP является чрезвычайно гибким и может быть использован в различных областях, где требуется временная синхронизация, обеспечивая точность до 10 нс

## Терминология

Гроссмейстерские часы -часы, являющиеся основным источником данных о времени при синхронизации согласно протоколу PTP, которые, как правило, оснащаются встроенным приемником сигналов GPS (или другой системы)

Ведущие часы -часы, являющиеся источником данных о времени, по которым

синхронизируются другие часы в сети (чаще всего это и есть гроссмейстерские часы) Ведомые часы -конечное устройство, которое синхронизируется по протоколу PTP Прозрачные часы -коммутатор, который измеряет время прохождения сообщения синхронизации через себя, канальную задержку и предоставляет измеренное значение часам, получающим сообщение синхронизации далее часы, которые оснащаются несколькими портами PTP и могут

Граничные часы -выступать ведущими часами; например, могут быть ведомыми по отношению к вышестоящим источникам сигналов времени и выступать в качестве ведущих по отношению к нижестоящим устройствам

Существуют 2 режима работы PTPv2:

- End-to-End ( E2E)

<!-- image -->

В данном режиме сетевое оборудование (коммутаторы) работают в режиме прозрачных часов. Задержка измеряется мастером для всего пути от мастера до каждого конечного

устройства в отдельности. Сеанс работы описан тут

Из этого следует минус такого режима -большая нагрузка на мастера

- Peer-to-peer (P2P)

<!-- image -->

Все коммутаторы должны поддерживать PTP. В этом случае коммутаторы заранее измеряют задержку каждого своего канала

(красные стрелки на картинке), в следствии чего при перестроении топологии перестроение PTP быстрое.

## Сеанс работы P2P

Announce message -сообщение анонса, содержит информацию, отправляемую мастером всем Slave устройствам. Slave устройство с помощью этого сообщения может выбрать лучшего мастера (для этого существует BMC (Best Master Clock)) алгоритм. Выбор идет по таким полям сообщения как точность, дисперсия, класс, приоритет и т.п.

Приоритет полей для алгоритма BMC (Best Master Clock)

1. priority1: Настраивается пользователем, по умолчанию значение 128. (чем меньше значение, тем выше приоритет)
2. clockClass: Зависит от погрешности и количества спутников. (необходимый для PTP 6 класс)
3. clockAccuracy: Точность (25 нс, 100 нс, 250нс, 1 мкс, 2.5 мкс, 10 мкс, 25 мкс, 100 мкс, 250 мкс, 1 мс, 10 с и &gt; 10 с)
4. offsetScaledLogVariance: стабильность часов
5. priority2: Настраивается пользователем, по умолчанию значение 128. (чем меньше значение, тем выше приоритет)
6. MAC Address

## Sync/Follow Up, PDelayResp/PDelayFollowUp -отправляются мастером

PDelayReq -запросы Slave устройств.

<!-- image -->

1. Сообщения типа Sync передаются прозрачными часами в неизменном виде.
2. t a -показание времени на гроссмейстерских часах. Таким же образом производится передача и сообщений типа Announce .
3. Каждые прозрачные часы измеряют время обработки сообщения Sync -t tc1
4. Каждые прозрачные часы вычисляют канальную задержку между соседними устройствами t p1 (рисунок ниже)

<!-- image -->

Происходит обмен сообщениями в двухстороннем порядке между соседними устройствами для вычисления канальной задержки. Схема вычисления представлена ниже.

<!-- image -->

При отправке запроса PDelayReq генерируется t1

При получении PDelayReq мастером генерируется время t2

Master отправляет PdelayResp c временем t2

Slave принимает PdelayResp и генерирует t4

Master отправляет PdelayRespFollowUP с временем t3

Зная t1, t2, t3, t4 Slave (прозрачные часы) вычисляют задержку канала связи (время доставки)

Теперь каждые прозрачные часы имеют время обработки сообщений ( t tc1 ), время канальных задержек ( t p1 ) и само время гроссмейстерских часов ( t a )

## Примечание

Если используется двухэтапный режим работы, то время гроссмейстерских часов устройства берут из сообщений FollowUp ( t b ). Но большинство устройств сейчас уже поддерживают одноэтапный режим работы Прозрачные часы получают время гроссмейстерских часов ( t a либо t b ). Далее в поле correction добавляют корректирующее значение ( t tc1 + t p1 ) Следующие прозрачные часы получают такое же время гроссмейстерских часов ( t a либо t b ), но уже с заполненным полем correction и суммируют значение поля со своими задержками ( t tc2 + t p2 ). Так продолжается до конечной точки (ведомых часов

'терминал РЗА')

<!-- image -->

## Сеанс работы E2E

Announce message -сообщение анонса, содержит информацию, отправляемую мастером всем Slave устройствам. Slave устройство с помощью этого сообщения может выбрать лучшего мастера (для этого существует BMC (Best Master Clock)) алгоритм. Выбор идет по таким полям сообщения как точность, дисперсия, класс, приоритет и т.п.

Приоритет полей для алгоритма BMC (Best Master Clock)

1. priority1: Настраивается пользователем, по умолчанию значение 128. (чем меньше значение, тем выше приоритет)
2. clockClass: Зависит от погрешности и количества спутников. (необходимый для PTP 6 класс)
3. clockAccuracy: Точность (25 нс, 100 нс, 250нс, 1 мкс, 2.5 мкс, 10 мкс, 25 мкс, 100 мкс, 250 мкс, 1 мс, 10 с и &gt; 10 с)
4. offsetScaledLogVariance: стабильность часов
5. priority2 : настраивается пользователем, по умолчанию значение 128. (чем меньше значение, тем выше приоритет)
6. MAC Address

## Sync/Follow Up, DelayResp -отправляются мастером

## DelayReq

-запросы Slave устройств.

<!-- image -->

1. В самом начале Master отправляет Announce message. Из всех мастеров Slave выбирает самого хорошего
2. Master отправляет Sync message и записывает время отправки этого сообщения t1 . Существует одно -и двухэтапные режимы работы. Отличить их очень легко: если присутствует сообщение FollowUp -то мы имеем дело с двухэтапной реализацией, пунктирной стрелкой показаны необязательные сообщения
3. Если двухэтапный режим, то FollowUp message содержит t1 , если одноэтапный режим, то t1 в Sync message
4. В момент получения Sync/FollowUp message на Slave генерируется t2
5. Slave генерирует DelayReq message и одновременно t3
6. При получении мастером DelayReq message генерируется t4
7. Master отправляет t4 в DelayResp message

Slave после получения t1, t2, t3, t4 вычисляет смещение и время доставки, а потом производит корректировку времени в Sync message.